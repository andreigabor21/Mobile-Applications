{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Andrei Gabor\\\\Desktop\\\\UNI\\\\3rd YEAR\\\\Mobile\\\\Labs\\\\cars-app\\\\src\\\\cars\\\\CarProvider.tsx\";\nimport React, { useCallback, useContext, useEffect, useReducer, useState } from \"react\";\nimport { getCars, createCar, editCar, createWebSocket, syncData } from \"./CarApi\";\nimport { getLogger } from '../core';\nimport { AuthContext } from \"../auth\";\nimport { Plugins } from \"@capacitor/core\";\nconst log = getLogger('CarProvider');\nconst {\n  Storage\n} = Plugins;\n;\n;\nconst initialState = {\n  fetching: false,\n  saving: false\n};\nconst FETCH_ITEMS_STARTED = 'FETCH_ITEMS_STARTED';\nconst FETCH_ITEMS_SUCCEEDED = 'FETCH_ITEMS_SUCCEEDED';\nconst FETCH_ITEMS_FAILED = 'FETCH_ITEMS_FAILED';\nconst SAVE_ITEM_STARTED = 'SAVE_ITEM_STARTED';\nconst SAVE_ITEM_SUCCEEDED = 'SAVE_ITEM_SUCCEEDED';\nconst SAVE_ITEM_FAILED = 'SAVE_ITEM_FAILED';\n\nconst reducer = (state, {\n  type,\n  payload\n}) => {\n  switch (type) {\n    case FETCH_ITEMS_STARTED:\n      return { ...state,\n        fetching: true,\n        fetchingError: null\n      };\n\n    case FETCH_ITEMS_SUCCEEDED:\n      return { ...state,\n        cars: payload.cars,\n        fetching: false\n      };\n\n    case FETCH_ITEMS_FAILED:\n      return { ...state,\n        cars: payload.cars,\n        fetching: false\n      };\n\n    case SAVE_ITEM_STARTED:\n      return { ...state,\n        savingError: null,\n        saving: true\n      };\n\n    case SAVE_ITEM_SUCCEEDED:\n      const cars = [...(state.cars || [])];\n      const item = payload.item;\n      const index = cars.findIndex(it => it._id === item._id);\n\n      if (index === -1) {\n        cars.splice(0, 0, item);\n      } else {\n        cars[index] = item;\n      }\n\n      return { ...state,\n        cars: cars,\n        saving: false\n      };\n\n    case SAVE_ITEM_FAILED:\n      return { ...state,\n        savingError: payload.error,\n        saving: false\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport const CarContext = React.createContext(initialState);\nconst {\n  Network\n} = Plugins;\nexport const CarProvider = ({\n  children\n}) => {\n  const {\n    token\n  } = useContext(AuthContext);\n  const [connectedNetworkStatus, setConnectedNetworkStatus] = useState(false);\n  Network.getStatus().then(status => setConnectedNetworkStatus(status.connected));\n  const [savedOffline, setSavedOffline] = useState(false);\n  useEffect(networkEffect, [token, setConnectedNetworkStatus]);\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const {\n    cars,\n    fetching,\n    fetchingError,\n    saving,\n    savingError\n  } = state;\n  useEffect(getCarsEffect, [token]);\n  useEffect(ws, [token]);\n  const saveCar = useCallback(saveCarCallback, [token]);\n  const value = {\n    cars,\n    fetching,\n    fetchingError,\n    saving,\n    savingError,\n    saveCar: saveCar,\n    connectedNetworkStatus,\n    savedOffline,\n    setSavedOffline\n  };\n  return /*#__PURE__*/React.createElement(CarContext.Provider, {\n    value: value,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 9\n    }\n  }, children);\n\n  function networkEffect() {\n    console.log(\"network effect\");\n    let canceled = false;\n    Network.addListener('networkStatusChange', async status => {\n      if (canceled) return;\n      const connected = status.connected;\n\n      if (connected) {\n        alert(\"SYNC data\");\n        await syncData(token);\n      }\n\n      setConnectedNetworkStatus(status.connected);\n    });\n    return () => {\n      canceled = true;\n    };\n  }\n\n  function getCarsEffect() {\n    let canceled = false;\n    fetchCars();\n    return () => {\n      canceled = true;\n    };\n\n    async function fetchCars() {\n      let canceled = false;\n      fetchCars();\n      return () => {\n        canceled = true;\n      };\n\n      async function fetchCars() {\n        var _navigator;\n\n        if (!(token === null || token === void 0 ? void 0 : token.trim())) return;\n\n        if (!((_navigator = navigator) === null || _navigator === void 0 ? void 0 : _navigator.onLine)) {\n          alert(\"LE IAU OFFLINE DIN STORAGE\");\n          let storageKeys = Storage.keys();\n          const cars = await storageKeys.then(async function (storageKeys) {\n            const saved = [];\n\n            for (let i = 0; i < storageKeys.keys.length; i++) {\n              if (storageKeys.keys[i] !== \"token\") {\n                const car = await Storage.get({\n                  key: storageKeys.keys[i]\n                });\n                if (car.value != null) var parsedCar = JSON.parse(car.value);\n                saved.push(parsedCar);\n              }\n            }\n\n            return saved;\n          });\n          dispatch({\n            type: FETCH_ITEMS_SUCCEEDED,\n            payload: {\n              cars: cars\n            }\n          });\n        } else {\n          try {\n            log('fetchCars started');\n            dispatch({\n              type: FETCH_ITEMS_STARTED\n            });\n            const cars = await getCars(token);\n            log('fetchCars successful');\n\n            if (!canceled) {\n              dispatch({\n                type: FETCH_ITEMS_SUCCEEDED,\n                payload: {\n                  cars: cars\n                }\n              });\n            }\n          } catch (error) {\n            let storageKeys = Storage.keys();\n            const cars = await storageKeys.then(async function (storageKeys) {\n              const saved = [];\n\n              for (let i = 0; i < storageKeys.keys.length; i++) {\n                if (storageKeys.keys[i] !== \"token\") {\n                  const car = await Storage.get({\n                    key: storageKeys.keys[i]\n                  });\n                  if (car.value != null) var parsedCar = JSON.parse(car.value);\n                  saved.push(parsedCar);\n                }\n              }\n\n              return saved;\n            });\n            dispatch({\n              type: FETCH_ITEMS_SUCCEEDED,\n              payload: {\n                cars: cars\n              }\n            });\n          }\n        }\n      }\n    }\n  }\n\n  async function saveCarCallback(item) {\n    try {\n      if (navigator.onLine) {\n        log('saveCar started');\n        dispatch({\n          type: SAVE_ITEM_STARTED\n        });\n        const updatedCar = await (item._id ? editCar(token, item) : createCar(token, item));\n        log('saveCar successful');\n        dispatch({\n          type: SAVE_ITEM_SUCCEEDED,\n          payload: {\n            item: updatedCar\n          }\n        });\n      } else {\n        alert('saveCar offline');\n        log('saveCar failed');\n        item._id = item._id == undefined ? '_' + Math.random().toString(36).substr(2, 9) : item._id;\n        await Storage.set({\n          key: item._id,\n          value: JSON.stringify({\n            _id: item._id,\n            model: item.model,\n            price: item.price,\n            available: item.available\n          })\n        });\n        dispatch({\n          type: SAVE_ITEM_SUCCEEDED,\n          payload: {\n            item: item\n          }\n        });\n        setSavedOffline(true);\n      }\n    } catch (error) {\n      log('saveCar failed');\n      await Storage.set({\n        key: String(item._id),\n        value: JSON.stringify(item)\n      });\n      dispatch({\n        type: SAVE_ITEM_SUCCEEDED,\n        payload: {\n          item: item\n        }\n      });\n    }\n  }\n\n  function ws() {\n    let canceled = false;\n    log('wsEffect - connecting');\n    let closeWebSocket;\n\n    if (token === null || token === void 0 ? void 0 : token.trim()) {\n      closeWebSocket = createWebSocket(token, message => {\n        if (canceled) {\n          return;\n        }\n\n        const {\n          type,\n          payload: item\n        } = message;\n        log(`ws message, item ${type}`);\n\n        if (type === 'created' || type === 'updated') {\n          dispatch({\n            type: SAVE_ITEM_SUCCEEDED,\n            payload: {\n              item\n            }\n          });\n        }\n      });\n    }\n\n    return () => {\n      var _closeWebSocket;\n\n      log('wsEffect - disconnecting');\n      canceled = true;\n      (_closeWebSocket = closeWebSocket) === null || _closeWebSocket === void 0 ? void 0 : _closeWebSocket();\n    };\n  }\n};","map":{"version":3,"sources":["C:/Users/Andrei Gabor/Desktop/UNI/3rd YEAR/Mobile/Labs/cars-app/src/cars/CarProvider.tsx"],"names":["React","useCallback","useContext","useEffect","useReducer","useState","getCars","createCar","editCar","createWebSocket","syncData","getLogger","AuthContext","Plugins","log","Storage","initialState","fetching","saving","FETCH_ITEMS_STARTED","FETCH_ITEMS_SUCCEEDED","FETCH_ITEMS_FAILED","SAVE_ITEM_STARTED","SAVE_ITEM_SUCCEEDED","SAVE_ITEM_FAILED","reducer","state","type","payload","fetchingError","cars","savingError","item","index","findIndex","it","_id","splice","error","CarContext","createContext","Network","CarProvider","children","token","connectedNetworkStatus","setConnectedNetworkStatus","getStatus","then","status","connected","savedOffline","setSavedOffline","networkEffect","dispatch","getCarsEffect","ws","saveCar","saveCarCallback","value","console","canceled","addListener","alert","fetchCars","trim","navigator","onLine","storageKeys","keys","saved","i","length","car","get","key","parsedCar","JSON","parse","push","updatedCar","undefined","Math","random","toString","substr","set","stringify","model","price","available","String","closeWebSocket","message"],"mappings":"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","sourcesContent":["import React, { useCallback, useContext, useEffect, useReducer, useState } from \"react\";\r\nimport { CarProps } from \"./CarProps\";\r\nimport PropTypes from 'prop-types';\r\nimport { getCars, createCar, editCar, createWebSocket, syncData } from \"./CarApi\";\r\nimport { getLogger } from '../core';\r\nimport { AuthContext } from \"../auth\";\r\nimport { Plugins } from \"@capacitor/core\";\r\n\r\nconst log = getLogger('CarProvider');\r\nconst { Storage } = Plugins;\r\n\r\nexport type saveCarFunction = (item : any) => Promise<any>;\r\n\r\nexport interface CarsState {\r\n    cars? : CarProps[],\r\n    fetching: boolean,\r\n    fetchingError? : Error | null,\r\n    saving: boolean,\r\n    savingError? : Error | null,\r\n    saveCar? : saveCarFunction,\r\n    connectedNetwork?: boolean,\r\n    setSavedOffline?: Function,\r\n    savedOffline?: boolean\r\n};\r\n\r\ninterface ActionProps {\r\n    type: string,\r\n    payload? : any\r\n};\r\n\r\nconst initialState: CarsState = {\r\n    fetching: false,\r\n    saving: false\r\n};\r\n\r\nconst FETCH_ITEMS_STARTED = 'FETCH_ITEMS_STARTED';\r\nconst FETCH_ITEMS_SUCCEEDED = 'FETCH_ITEMS_SUCCEEDED';\r\nconst FETCH_ITEMS_FAILED = 'FETCH_ITEMS_FAILED';\r\nconst SAVE_ITEM_STARTED = 'SAVE_ITEM_STARTED';\r\nconst SAVE_ITEM_SUCCEEDED = 'SAVE_ITEM_SUCCEEDED';\r\nconst SAVE_ITEM_FAILED = 'SAVE_ITEM_FAILED';\r\n\r\nconst reducer: (state: CarsState, action: ActionProps) => CarsState = \r\n(state, {type, payload}) => {\r\n    switch(type) {\r\n        case FETCH_ITEMS_STARTED:\r\n            return {...state, fetching: true, fetchingError: null};\r\n        case FETCH_ITEMS_SUCCEEDED:\r\n            return {...state, cars: payload.cars, fetching: false};\r\n        case FETCH_ITEMS_FAILED:\r\n            return {...state, cars: payload.cars, fetching: false};\r\n        case SAVE_ITEM_STARTED:\r\n            return {...state, savingError: null, saving: true};\r\n        case SAVE_ITEM_SUCCEEDED:\r\n            const cars = [...(state.cars || [])]\r\n            const item = payload.item;            \r\n            const index = cars.findIndex(it => it._id === item._id);\r\n            if (index === -1) {\r\n                cars.splice(0, 0, item);\r\n            } else {\r\n                cars[index] = item;\r\n            }\r\n            return {...state, cars: cars, saving: false};\r\n        case SAVE_ITEM_FAILED:\r\n            return {...state, savingError: payload.error, saving: false};\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\nexport const CarContext = React.createContext<CarsState>(initialState);\r\n\r\ninterface CarProviderProps {\r\n    children: PropTypes.ReactNodeLike\r\n}\r\n\r\nconst {Network} = Plugins;\r\n\r\nexport const CarProvider: React.FC<CarProviderProps> = ({children}) => {\r\n    const { token } = useContext(AuthContext);\r\n\r\n    const [connectedNetworkStatus, setConnectedNetworkStatus] = useState<boolean>(false);\r\n    Network.getStatus().then(status => setConnectedNetworkStatus(status.connected));\r\n    const [savedOffline, setSavedOffline] = useState<boolean>(false);\r\n    useEffect(networkEffect, [token, setConnectedNetworkStatus]);\r\n\r\n    const [state, dispatch] = useReducer(reducer, initialState);\r\n    const { cars, fetching, fetchingError, saving, savingError } = state;\r\n    useEffect(getCarsEffect, [token]);\r\n    useEffect(ws, [token])\r\n    const saveCar = useCallback<saveCarFunction>(saveCarCallback, [token]);\r\n    const value  = {\r\n        cars, \r\n        fetching, \r\n        fetchingError, \r\n        saving, \r\n        savingError, \r\n        saveCar: saveCar, \r\n        connectedNetworkStatus, \r\n        savedOffline, \r\n        setSavedOffline \r\n    };\r\n    return (\r\n        <CarContext.Provider value={value}>\r\n        {children}\r\n        </CarContext.Provider>\r\n    );\r\n\r\n    function networkEffect() {\r\n        console.log(\"network effect\");\r\n        let canceled = false;\r\n        Network.addListener('networkStatusChange', async (status) => {\r\n            if (canceled) return;\r\n            const connected = status.connected;\r\n            if (connected) {\r\n                alert(\"SYNC data\");\r\n                await syncData(token);\r\n            }\r\n            setConnectedNetworkStatus(status.connected);\r\n        });\r\n        return () => {\r\n            canceled = true;\r\n        }\r\n    }\r\n\r\n    function getCarsEffect() {\r\n        let canceled = false;\r\n        fetchCars();\r\n        return () => {\r\n            canceled = true;\r\n        }\r\n\r\n        async function fetchCars() {\r\n            let canceled = false;\r\n            fetchCars();\r\n            return () => {\r\n                canceled = true;\r\n            }\r\n\r\n            async function fetchCars() {\r\n                if (!token?.trim()) return;\r\n                if (!navigator?.onLine) {\r\n                    alert(\"LE IAU OFFLINE DIN STORAGE\")\r\n                    let storageKeys = Storage.keys();\r\n                    const cars = await storageKeys.then(async function (storageKeys) {\r\n                        const saved = [];\r\n                        for (let i = 0; i < storageKeys.keys.length; i++) {\r\n                            if (storageKeys.keys[i] !== \"token\") {\r\n                                const car = await Storage.get({key : storageKeys.keys[i]});\r\n                                if (car.value != null)\r\n                                    var parsedCar = JSON.parse(car.value);\r\n                                saved.push(parsedCar);\r\n                            }\r\n                        }\r\n                        return saved;\r\n                    });\r\n                    dispatch({type: FETCH_ITEMS_SUCCEEDED, payload: {cars: cars}});\r\n                } else {\r\n                    try {\r\n                        log('fetchCars started');\r\n                        dispatch({type: FETCH_ITEMS_STARTED});\r\n                        const cars = await getCars(token);\r\n                        log('fetchCars successful');\r\n                        if (!canceled) {\r\n                            dispatch({type: FETCH_ITEMS_SUCCEEDED, payload: {cars: cars}})\r\n                        }\r\n                    } catch (error) {\r\n                        let storageKeys = Storage.keys();\r\n                        const cars = await storageKeys.then(async function (storageKeys) {\r\n                            const saved = [];\r\n                            for (let i = 0; i < storageKeys.keys.length; i++) {\r\n                                if (storageKeys.keys[i] !== \"token\") {\r\n                                    const car = await Storage.get({key : storageKeys.keys[i]});\r\n                                    if (car.value != null)\r\n                                        var parsedCar = JSON.parse(car.value);\r\n                                    saved.push(parsedCar);\r\n                                }\r\n                            }\r\n                            return saved;\r\n                        });\r\n                        dispatch({type: FETCH_ITEMS_SUCCEEDED, payload: {cars: cars}});\r\n                    }\r\n                }\r\n                \r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    async function saveCarCallback(item: CarProps) {\r\n        try {\r\n            if (navigator.onLine) {\r\n                log('saveCar started');\r\n                dispatch({ type: SAVE_ITEM_STARTED });\r\n                const updatedCar = await (item._id ? editCar(token, item) : createCar(token, item))\r\n                log('saveCar successful');\r\n                dispatch({type: SAVE_ITEM_SUCCEEDED, payload: {item: updatedCar}});\r\n            }\r\n            \r\n            else {\r\n                alert('saveCar offline');\r\n                log('saveCar failed');\r\n                item._id = (item._id == undefined) ? ('_' + Math.random().toString(36).substr(2, 9)) : item._id;\r\n                await Storage.set({\r\n                    key: item._id!,\r\n                    value: JSON.stringify({\r\n                      _id: item._id,\r\n                      model: item.model,\r\n                      price: item.price,\r\n                      available: item.available\r\n                      })\r\n                  });\r\n                dispatch({type: SAVE_ITEM_SUCCEEDED, payload: {item : item}});\r\n                setSavedOffline(true);\r\n            }\r\n        }\r\n        catch(error) {\r\n            log('saveCar failed');\r\n            await Storage.set({\r\n                key: String(item._id),\r\n                value: JSON.stringify(item)\r\n            })\r\n            dispatch({type: SAVE_ITEM_SUCCEEDED, payload: {item : item}});\r\n        }\r\n    }\r\n\r\n    function ws() {\r\n        let canceled = false;\r\n        log('wsEffect - connecting');\r\n        let closeWebSocket: () => void;\r\n        if (token?.trim()) {\r\n          closeWebSocket = createWebSocket(token, message => {\r\n            if (canceled) {\r\n              return;\r\n            }\r\n            const { type, payload: item } = message;\r\n            log(`ws message, item ${type}`);\r\n            if (type === 'created' || type === 'updated') {\r\n              dispatch({ type: SAVE_ITEM_SUCCEEDED, payload: { item } });\r\n            }\r\n          });\r\n        }\r\n        return () => {\r\n          log('wsEffect - disconnecting');\r\n          canceled = true;\r\n          closeWebSocket?.();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}